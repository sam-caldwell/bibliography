package main

import (
    "fmt"
    "html/template"
    "os"
    "path/filepath"
    "sort"
    "strings"

    "github.com/spf13/cobra"

    "bibliography/src/internal/schema"
    "bibliography/src/internal/store"
)

func newPublishCmd() *cobra.Command {
    cmd := &cobra.Command{
        Use:   "publish",
        Short: "Publish HTML pages for all citations under docs/ with an index",
        RunE: func(cmd *cobra.Command, args []string) error {
            entries, err := store.ReadAll()
            if err != nil {
                return err
            }
            if err := os.MkdirAll("docs", 0o755); err != nil {
                return err
            }
            // Build per-entry pages and collect for index by category
            byCat := map[string][]schema.Entry{}
            for _, e := range entries {
                seg := store.SegmentForType(e.Type)
                byCat[seg] = append(byCat[seg], e)
                if err := writeEntryPage(e, seg); err != nil {
                    return err
                }
            }
            if err := writeIndex(byCat); err != nil {
                return err
            }
            fmt.Fprintln(cmd.OutOrStdout(), "wrote docs/index.html and per-entry pages")
            return nil
        },
    }
    return cmd
}

var entryTmpl = template.Must(template.New("entry").Funcs(template.FuncMap{
    "join": strings.Join,
}).Parse(`<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>{{.APA7.Title}}</title>
  <style>
    body{font:16px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;max-width:860px;margin:2rem auto;padding:0 1rem;color:#222}
    header,footer{color:#666}
    h1{font-size:1.6rem;margin:0.2rem 0 0.6rem}
    .meta{margin:0.4rem 0}
    .block{margin:0.8rem 0}
    a{color:#0b66d6;text-decoration:none}
    a:hover{text-decoration:underline}
    .kw span{display:inline-block;background:#eef;padding:2px 6px;margin:2px;border-radius:10px;font-size:0.85em}
  </style>
  <link rel="canonical" href="{{.Canonical}}" />
  <meta name="description" content="Annotated citation for {{.APA7.Title}}" />
  <meta property="og:title" content="{{.APA7.Title}}" />
  <meta property="og:type" content="article" />
  <meta property="og:url" content="{{.Canonical}}" />
  {{with .APA7.URL}}<meta property="og:see_also" content="{{.}}" />{{end}}
  {{with .APA7.DOI}}<meta name="citation_doi" content="{{.}}" />{{end}}
  <meta name="citation_title" content="{{.APA7.Title}}" />
  {{range .APA7.Authors}}<meta name="citation_author" content="{{.Family}}{{if .Given}}, {{.Given}}{{end}}" />
  {{end}}
  {{with .APA7.Journal}}<meta name="citation_journal_title" content="{{.}}" />{{end}}
  {{with .APA7.ContainerTitle}}<meta name="citation_inbook_title" content="{{.}}" />{{end}}
  {{with .APA7.Date}}<meta name="citation_publication_date" content="{{.}}" />{{end}}
  {{with .APA7.ISBN}}<meta name="citation_isbn" content="{{.}}" />{{end}}
</head>
<body>
  <header><a href="../index.html">‚Üê Index</a></header>
  <main>
    <h1>{{.APA7.Title}}</h1>
    <div class="meta">
      <div><strong>Type:</strong> {{.Type}}</div>
      {{if .APA7.Authors}}
      <div><strong>Authors:</strong> {{range $i, $a := .APA7.Authors}}{{if $i}}, {{end}}{{$a.Family}}{{if $a.Given}}, {{$a.Given}}{{end}}{{end}}</div>
      {{end}}
      {{with .APA7.Journal}}<div><strong>Journal:</strong> {{.}}</div>{{end}}
      {{with .APA7.ContainerTitle}}<div><strong>Container:</strong> {{.}}</div>{{end}}
      {{with .APA7.Publisher}}<div><strong>Publisher:</strong> {{.}}</div>{{end}}
      {{with .APA7.Date}}<div><strong>Date:</strong> {{.}}</div>{{end}}
      {{with .APA7.DOI}}<div><strong>DOI:</strong> <a href="https://doi.org/{{.}}">{{.}}</a></div>{{end}}
      {{with .APA7.URL}}<div><strong>URL:</strong> <a href="{{.}}">{{.}}</a></div>{{end}}
      <div><strong>ID:</strong> {{.ID}}</div>
    </div>
    <div class="block">
      <h2>Summary</h2>
      <p>{{.Annotation.Summary}}</p>
    </div>
    {{if .Annotation.Keywords}}
    <div class="block kw">
      <h3>Keywords</h3>
      {{range .Annotation.Keywords}}<span>{{.}}</span>{{end}}
    </div>
    {{end}}
  </main>
  <footer><small>Generated by bib publish</small></footer>
</body>
</html>
`))

type entryPageModel struct {
    schema.Entry
    Canonical string
}

func writeEntryPage(e schema.Entry, seg string) error {
    dir := filepath.Join("docs", seg)
    if err := os.MkdirAll(dir, 0o755); err != nil {
        return err
    }
    out := filepath.Join(dir, e.ID+".html")
    f, err := os.Create(out)
    if err != nil {
        return err
    }
    defer f.Close()
    model := entryPageModel{Entry: e, Canonical: filepath.ToSlash(filepath.Join(seg, e.ID+".html"))}
    return entryTmpl.Execute(f, model)
}

var indexTmpl = template.Must(template.New("index").Parse(`<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Bibliography Index</title>
  <style>
    body{font:16px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;max-width:980px;margin:2rem auto;padding:0 1rem;color:#222}
    h1{font-size:1.8rem}
    h2{margin-top:1.2rem}
    ul{list-style:disc;padding-left:1.2rem}
    .cat{margin-bottom:1.2rem}
    a{color:#0b66d6;text-decoration:none}
    a:hover{text-decoration:underline}
  </style>
</head>
<body>
  <main>
    <h1>Works</h1>
    {{range .Categories}}
    <div class="cat">
      <h2>{{.Name}}</h2>
      <ul>
        {{range .Items}}
        <li><a href="{{.Href}}">{{.Title}}</a></li>
        {{end}}
      </ul>
    </div>
    {{end}}
  </main>
</body>
</html>
`))

type indexCategory struct {
    Name  string
    Items []indexItem
}

type indexItem struct {
    Title string
    Href  string
}

type indexModel struct {
    Categories []indexCategory
}

func writeIndex(byCat map[string][]schema.Entry) error {
    // Stable order: category name ascending, then title ascending
    var cats []string
    for c := range byCat {
        cats = append(cats, c)
    }
    sort.Strings(cats)
    var model indexModel
    for _, c := range cats {
        es := byCat[c]
        sort.Slice(es, func(i, j int) bool { return strings.ToLower(es[i].APA7.Title) < strings.ToLower(es[j].APA7.Title) })
        var items []indexItem
        for _, e := range es {
            items = append(items, indexItem{Title: e.APA7.Title, Href: filepath.ToSlash(filepath.Join(c, e.ID+".html"))})
        }
        model.Categories = append(model.Categories, indexCategory{Name: c, Items: items})
    }
    f, err := os.Create(filepath.Join("docs", "index.html"))
    if err != nil {
        return err
    }
    defer f.Close()
    return indexTmpl.Execute(f, model)
}
